# simple-sqlite
Reference: https://cstack.github.io/db_tutorial/

## Build
```
>> mkdir build && cd build
>> cmake -DCMAKE_BUILD_TYPE=Debug ..
>> make
>> ./simpleSQLite
```

## Test
```
db > insert 1 ben ben@gmail.com
Executed.

db > insert 2 tom tom@yahoo.com
Executed.

db > select
(1, ben, ben@gmail.com)
(2, tom, tom@yahoo.com)
Executed.
```

## Project Related
Basic Steps:
Read Input -> Execute Meta Command -> Prepare Statement -> Execute Statement

## C Knowledge
### ssize_t
ssize_t is a data type commonly used in programming to represent sizes or counts of bytes. It stands for "signed size type". It's often used when dealing with functions or operations that involve reading or writing data, such as file I/O or memory operations.

The key feature of ssize_t is that it's a signed integer type, which means it can represent both positive and negative values. This is important because functions that return sizes or counts might use negative values to indicate errors or special conditions.

For example, in C programming, when you're working with functions like read() or write() for reading from or writing to files or sockets, the return type is often ssize_t. Similarly, the fread() and fwrite() functions for reading and writing data from and to streams also use ssize_t to indicate the number of bytes read or written.

### Calculate the size of a struct
```
sizeof(((Struct*)0)->Attribute)
```

### How to handle command input
```
typedef struct {
    char* buffer;
    size_t buffer_length;
    ssize_t input_length;
} InputBuffer;

InputBuffer* new_input_buffer() {
    InputBuffer* input_buffer = (InputBuffer*) malloc(sizeof(InputBuffer));

    input_buffer->buffer = NULL;
    input_buffer->buffer_length = 0;
    input_buffer->input_length = 0;

    return input_buffer;
}
```

### input_length and buffer_length
input_length is the number of bytes that the user has typed into the console. buffer_length is the size of the allocated buffer.

Generally speaking, the buffer_length is power of 2. For example, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, etc.

## DB Knowledge
### SQList Architecture
#### Architecture
Tokenizer -> Parser -> Code Generator -> Virtual Machine -> B-Tree -> Pager -> OS Interface

#### Front end
Tokenizer -> Parser -> Code Generator

#### Back end:  
Virtual Machine -> B-Tree -> Pager -> OS Interface

#### Virtual Machine
The virtual machine takes bytecode generated by the front-end as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a data structure called a B-tree. The VM is essentially a big switch statement on the type of bytecode instruction.

#### Pager (Buffer)
The pager receives commands to read or write pages of data. It is responsible for reading/writing at appropriate offsets in the database file. It also keeps a cache of recently-accessed pages in memory, and determines when those pages need to be written back to disk.
